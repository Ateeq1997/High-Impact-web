package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"fmt"
	"graphql-postgres/graph/model"
	"strconv"
	"time"

	jwt "github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

var jwtSecretKey = []byte("your-secret-key-change-this")

type CustomClaims struct {
	ID       int32  `json:"id"`
	Email    string `json:"email"`
	Username string `json:"username"`
	Role     string `json:"role"`
	jwt.RegisteredClaims
}

func validateJWT(tokenString string) (*CustomClaims, error) {
	claims := &CustomClaims{}

	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtSecretKey, nil
	})

	if err != nil || !token.Valid {
		return nil, err
	}

	return claims, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.LoginResponse, error) {
	// Step 1: Query user by email
	var userID int32
	var username, role, storedHash, joined string
	var status bool

	err := r.DB.QueryRowContext(ctx,
		`SELECT "ID", "Username", "Password", "Email", "Role", "Status", "Joined" FROM user_account_data WHERE "Email" = $1`, email).
		Scan(&userID, &username, &storedHash, &email, &role, &status, &joined)
	if err != nil {
		return &model.LoginResponse{
			Success: false,
			Message: "Invalid email or password",
			Token:   nil,
			User:    nil,
		}, nil
	}

	// Step 2: Check if account is active
	if !status {
		return &model.LoginResponse{
			Success: false,
			Message: "Account is inactive",
			Token:   nil,
			User:    nil,
		}, nil
	}

	// Step 3: Compare hashed password
	err = bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password))
	if err != nil {
		return &model.LoginResponse{
			Success: false,
			Message: "Invalid email or password",
			Token:   nil,
			User:    nil,
		}, nil
	}

	// Step 4: Generate JWT token
	claims := CustomClaims{
		ID:       userID,
		Email:    email,
		Username: username,
		Role:     role,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)), // 24 hour expiry
			IssuedAt:  jwt.NewNumericDate(time.Now()),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtSecretKey)
	if err != nil {
		return &model.LoginResponse{
			Success: false,
			Message: "Failed to generate token",
			Token:   nil,
			User:    nil,
		}, err
	}

	// Step 5: Return user info with token
	user := &model.UserAccountData{
		ID:       userID,
		Username: &username,
		Email:    &email,
		Password: nil, // Never return password even if in schema
		Role:     &role,
		Status:   &status,
		Joined:   &joined,
	}

	return &model.LoginResponse{
		Success: true,
		Message: "Login successful",
		Token:   &tokenString,
		User:    user,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, token string) (*model.LogoutResponse, error) {
	// Validate token exists and is valid
	_, err := validateJWT(token)
	if err != nil {
		return &model.LogoutResponse{
			Success: false,
			Message: "Invalid token",
		}, nil
	}

	// With JWT, logout is client-side (delete token from frontend)
	// No server-side invalidation needed unless using token blacklist
	return &model.LogoutResponse{
		Success: true,
		Message: "Logged out successfully",
	}, nil
}

// RequestPasswordReset is the resolver for the requestPasswordReset field.
func (r *mutationResolver) RequestPasswordReset(ctx context.Context, email string) (*model.PasswordResetResponse, error) {
	// Check if user exists
	var userID int32
	err := r.DB.QueryRowContext(ctx, `SELECT "ID" FROM user_account_data WHERE "Email" = $1`, email).Scan(&userID)
	if err != nil {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "If this email exists, a reset link has been sent",
		}, nil
	}

	// Generate token
	token := uuid.New().String()
	expireAt := time.Now().Add(1 * time.Hour).Format("2006-01-02T15:04:05Z07:00")
	created := time.Now().Format("2006-01-02T15:04:05Z07:00")
	// Insert reset token
	_, err = r.DB.ExecContext(ctx,
		`INSERT INTO forgot_password_functionality ("User_ID", "Email", "Token", "Expire_at", "Used", "Created") VALUES ($1, $2, $3, $4, $5, $6)`,
		userID, email, token, expireAt, false, created)
	if err != nil {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Failed to create reset token",
		}, err
	}

	// TODO: Send email with token

	return &model.PasswordResetResponse{
		Success: true,
		Message: "If this email exists, a reset link has been sent",
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, token string, newPassword string) (*model.PasswordResetResponse, error) {
	// Validate token
	var userID int32
	var expireAt string
	var used bool
	err := r.DB.QueryRowContext(ctx,
		`SELECT "User_ID", "Expire_at", "Used" FROM forgot_password_functionality WHERE "Token" = $1`, token).Scan(&userID, &expireAt, &used)
	if err != nil {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Invalid or expired token",
		}, nil
	}

	// Check if already used
	if used {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Token has already been used",
		}, nil
	}

	// Check expiration
	expireTime, _ := time.Parse("2006-01-02T15:04:05Z07:00", expireAt)
	if time.Now().After(expireTime) {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Token has expired",
		}, nil
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
	if err != nil {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Failed to process password",
		}, err
	}

	// Update password
	_, err = r.DB.ExecContext(ctx,
		`UPDATE user_account_data SET "Password" = $1 WHERE "ID" = $2`, string(hashedPassword), userID)
	if err != nil {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Failed to update password",
		}, err
	}

	// Mark token as used
	_, err = r.DB.ExecContext(ctx,
		`UPDATE forgot_password_functionality SET "Used" = $1 WHERE "Token" = $2`, true, token)
	if err != nil {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Failed to mark token as used",
		}, err
	}

	return &model.PasswordResetResponse{
		Success: true,
		Message: "Password reset successfully",
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string) (*model.PasswordResetResponse, error) {
	// Check if email already exists
	var exists bool
	err := r.DB.QueryRowContext(ctx, `SELECT EXISTS(SELECT 1 FROM user_account_data WHERE "Email" = $1)`, email).Scan(&exists)
	if err != nil {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Registration failed",
		}, err
	}
	if exists {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Email already registered",
		}, nil
	}

	// Check if username already exists
	err = r.DB.QueryRowContext(ctx, `SELECT EXISTS(SELECT 1 FROM user_account_data WHERE "Username" = $1)`, username).Scan(&exists)
	if err != nil {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Registration failed",
		}, err
	}
	if exists {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Username already taken",
		}, nil
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Failed to process password",
		}, err
	}

	// Insert new user
	joined := time.Now().Format("2006-01-02T15:04:05Z07:00")
	_, err = r.DB.ExecContext(ctx,
		`INSERT INTO user_account_data ("Username", "Email", "Password", "Role", "Status", "Joined") VALUES ($1, $2, $3, $4, $5, $6)`,
		username, email, string(hashedPassword), "Farmer", true, joined)
	if err != nil {
		return &model.PasswordResetResponse{
			Success: false,
			Message: "Registration failed",
		}, err
	}

	return &model.PasswordResetResponse{
		Success: true,
		Message: "Registration successful",
	}, nil
}

// GetAreaProdOfImportantCrops is the resolver for the getAreaProdOfImportantCrops field.
func (r *queryResolver) GetAreaProdOfImportantCrops(ctx context.Context, year *string) ([]*model.AreaProdOfImportantCrops, error) {
	query := `SELECT "Year", "Area (Wheat)", "Production (Wheat)", "Area (Maize)", "Production (Maize)", "Area (Rice)", "Production (Rice)", "Area (Sugarcane)", "Production (Sugarcane)", "Area (Cotton)", "Production (Cotton)" FROM area_prod_of_important_crops`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.AreaProdOfImportantCrops
	for rows.Next() {
		var item model.AreaProdOfImportantCrops
		err := rows.Scan(&item.Year, &item.AreaWheat, &item.ProductionWheat, &item.AreaMaize, &item.ProductionMaize, &item.AreaRice, &item.ProductionRice, &item.AreaSugarcane, &item.ProductionSugarcane, &item.AreaCotton, &item.ProductionCotton)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetAreaProductionKharifVegetablesAjk is the resolver for the getAreaProductionKharifVegetablesAJK field.
func (r *queryResolver) GetAreaProductionKharifVegetablesAjk(ctx context.Context, district *string, vegetable *string, latitude *float64, longitude *float64) ([]*model.AreaProductionKharifVegetablesAjk, error) {
	query := `SELECT "District", "Vegetable_ID", "Vegetable", "Area 2019 (hect)", "Production 2019 (tons)", "Area 2020 (hect)", "Production 2020 (tons)", "Area 2021 (hect)", "Production 2021 (tons)" FROM "area_production_khairf_vegetables_AJK_19_21" WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
		argCounter++
	} else if district != nil {
		query += ` AND "District" = $` + strconv.Itoa(argCounter)
		args = append(args, *district)
		argCounter++
	}

	if vegetable != nil {
		query += ` AND "Vegetable" = $` + strconv.Itoa(argCounter)
		args = append(args, *vegetable)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.AreaProductionKharifVegetablesAjk
	for rows.Next() {
		var item model.AreaProductionKharifVegetablesAjk
		err := rows.Scan(&item.District, &item.VegetableID, &item.Vegetable, &item.Area2019Hect, &item.Production2019Tons, &item.Area2020Hect, &item.Production2020Tons, &item.Area2021Hect, &item.Production2021Tons)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetAreaProductionPercentageSharePunjabCrops is the resolver for the getAreaProductionPercentageSharePunjabCrops field.
func (r *queryResolver) GetAreaProductionPercentageSharePunjabCrops(ctx context.Context, crop *string, year *string) ([]*model.AreaProductionPercentageSharePunjabCrops, error) {
	query := `SELECT "Indicators", "Crop_ID", "Crop", "2007-08", "2008-09", "2009-10", "2010-11", "2011-12", "2012-13", "2013-14", "2014-15", "2015-16", "2016-17", "2017-18", "2018-19", "2019-20" FROM area_production_percentage_share_punjab_crops_2007_20 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	if crop != nil {
		query += ` AND "Crop" = $` + string(rune(argCounter+48))
		args = append(args, *crop)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.AreaProductionPercentageSharePunjabCrops
	for rows.Next() {
		var item model.AreaProductionPercentageSharePunjabCrops
		err := rows.Scan(&item.Indicators, &item.CropID, &item.Crop, &item.Year200708, &item.Year200809, &item.Year200910, &item.Year201011, &item.Year201112, &item.Year201213, &item.Year201314, &item.Year201415, &item.Year201516, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetAreaSownBySourceOfIrrigationSindh is the resolver for the getAreaSownBySourceOfIrrigationSindh field.
func (r *queryResolver) GetAreaSownBySourceOfIrrigationSindh(ctx context.Context, year *string) ([]*model.AreaSownBySourceOfIrrigationSindh, error) {
	query := `SELECT "Year", "Total", "Canal", "Well", "Tube Well", "Canal Well", "Canal Wells", "Others" FROM area_sown_by_source_of_irrigation_sindh`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.AreaSownBySourceOfIrrigationSindh
	for rows.Next() {
		var item model.AreaSownBySourceOfIrrigationSindh
		err := rows.Scan(&item.Year, &item.Total, &item.Canal, &item.Well, &item.TubeWell, &item.CanalWell, &item.CanalWells, &item.Others)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetAreaSownIrrigatedImportantCropsPunjab is the resolver for the getAreaSownIrrigatedImportantCropsPunjab field.
func (r *queryResolver) GetAreaSownIrrigatedImportantCropsPunjab(ctx context.Context, crops *string) ([]*model.AreaSownIrrigatedImportantCropsPunjab, error) {
	query := `SELECT "Crops", "2011-12", "2012-13", "2013-14", "2014-15", "2015-16", "2016-17", "2017-18", "2018-19", "2019-20", "2020-21" FROM area_sown_irrigated_important_crops_punjab`
	var args []interface{}
	if crops != nil {
		query += ` WHERE "Crops" = $1`
		args = append(args, *crops)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.AreaSownIrrigatedImportantCropsPunjab
	for rows.Next() {
		var item model.AreaSownIrrigatedImportantCropsPunjab
		err := rows.Scan(&item.Crops, &item.Year201112, &item.Year201213, &item.Year201314, &item.Year201415, &item.Year201516, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920, &item.Year202021)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetAreaSownIrrigationSource is the resolver for the getAreaSownIrrigationSource field.
func (r *queryResolver) GetAreaSownIrrigationSource(ctx context.Context, year *string) ([]*model.AreaSownIrrigationSource, error) {
	query := `SELECT "Year", "Total Area Sown", "Un-Irrigated", "Total Irrigated", "Irrigated by Canals", "Irrigated by Wells", "Irrigated by Tubewells", "Irrigated by Canalwells", "Irrigated by Canal Tubewells", "Irrigated by Others Sources" FROM area_sown_irrigation_source`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.AreaSownIrrigationSource
	for rows.Next() {
		var item model.AreaSownIrrigationSource
		err := rows.Scan(&item.Year, &item.TotalAreaSown, &item.UnIrrigated, &item.TotalIrrigated, &item.IrrigatedByCanals, &item.IrrigatedByWells, &item.IrrigatedByTubewells, &item.IrrigatedByCanalwells, &item.IrrigatedByCanalTubewells, &item.IrrigatedByOthersSources)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetAreaSownProdYieldWheatPunjab is the resolver for the getAreaSownProdYieldWheatPunjab field.
func (r *queryResolver) GetAreaSownProdYieldWheatPunjab(ctx context.Context, district *string, latitude *float64, longitude *float64) ([]*model.AreaSownProdYieldWheatPunjab, error) {
	query := `SELECT "Province/ Division/ District", "2007-08", "2008-09", "2009-10", "2010-11", "2011-12", "2012-13", "2013-14", "2014-15", "2015-16", "2016-17", "2017-18", "2018-19", "2019-20" FROM area_sown_prod_yield_wheat_punjab WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
		argCounter++
	} else if district != nil {
		query += ` AND "Province/ Division/ District" ILIKE $` + strconv.Itoa(argCounter)
		args = append(args, "%"+*district+"%")
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.AreaSownProdYieldWheatPunjab
	for rows.Next() {
		var item model.AreaSownProdYieldWheatPunjab
		err := rows.Scan(&item.ProvinceDivisionDistrict, &item.Year200708, &item.Year200809, &item.Year200910, &item.Year201011, &item.Year201112, &item.Year201213, &item.Year201314, &item.Year201415, &item.Year201516, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetAreaSownProductionCropsCombinedPunjab is the resolver for the getAreaSownProductionCropsCombinedPunjab field.
func (r *queryResolver) GetAreaSownProductionCropsCombinedPunjab(ctx context.Context, year *string, crop *string) ([]*model.AreaSownProductionCropsCombinedPunjab, error) {
	query := `SELECT "Year", "Crop_ID", "Crop", "Total Area Sown (1000 Hects)", "Area (1000 Hects)", "Production (1000 Hects)", "Index of Area Sown (Base year 2010-11)", "Index of Production (Base year 2010-11)", "% Share of Area Sown" FROM area_sown_production_crops_combined_punjab_2010_21 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	if year != nil {
		query += ` AND "Year" = $1`
		args = append(args, *year)
		argCounter++
	}
	if crop != nil {
		query += ` AND "Crop" = $` + string(rune(argCounter+48))
		args = append(args, *crop)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.AreaSownProductionCropsCombinedPunjab
	for rows.Next() {
		var item model.AreaSownProductionCropsCombinedPunjab
		err := rows.Scan(&item.Year, &item.CropID, &item.Crop, &item.TotalAreaSown1000Hects, &item.Area1000Hects, &item.Production1000Hects, &item.IndexOfAreaSownBaseYear201011, &item.IndexOfProductionBaseYear201011, &item.PercentShareOfAreaSown)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetAreaTreatedWithPesticidesCropsPunjab is the resolver for the getAreaTreatedWithPesticidesCropsPunjab field.
func (r *queryResolver) GetAreaTreatedWithPesticidesCropsPunjab(ctx context.Context, year *string) ([]*model.AreaTreatedWithPesticidesCropsPunjab, error) {
	query := `SELECT "Year", "Total Area", "Wheat", "Rice and Rice Nursery", "Cotton", "Maize", "Sugarcane", "Vegetables/Fruits", "Other Crops" FROM area_treated_with_pesticides_crops_punjab`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.AreaTreatedWithPesticidesCropsPunjab
	for rows.Next() {
		var item model.AreaTreatedWithPesticidesCropsPunjab
		err := rows.Scan(&item.Year, &item.TotalArea, &item.Wheat, &item.RiceAndRiceNursery, &item.Cotton, &item.Maize, &item.Sugarcane, &item.VegetablesFruits, &item.OtherCrops)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetAvgRetailPriceFertilizer is the resolver for the getAvgRetailPriceFertilizer field.
func (r *queryResolver) GetAvgRetailPriceFertilizer(ctx context.Context, year *string) ([]*model.AvgRetailPriceFertilizer, error) {
	query := `SELECT "Year", "Urea", "AN/CAN (26%N)", "AS (21%N)", "NP (20:22)", "SSP (G) (18%P)", "DAP (18:46)", "SOP (50%K)" FROM avg_retail_price_fertilizer_50kg`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.AvgRetailPriceFertilizer
	for rows.Next() {
		var item model.AvgRetailPriceFertilizer
		err := rows.Scan(&item.Year, &item.Urea, &item.AnCan26n, &item.As21n, &item.Np2022, &item.SspG18p, &item.Dap1846, &item.Sop50k)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetCanalWithdrawlsPunjab is the resolver for the getCanalWithdrawlsPunjab field.
func (r *queryResolver) GetCanalWithdrawlsPunjab(ctx context.Context, year *string, season *string) ([]*model.CanalWithdrawlsPunjab, error) {
	query := `SELECT "Year", "Season_ID", "Season", "All Canals (Punjab)", "Five Linked Canals", "M.R. Link (Internal)", "Haveli Canals", "Panjnad Canals", "Central Bari Doab Canals", "Sutlej Valley Canals", "Thal Canals", "Taunsa Canals", "C.R.B.C." FROM canal_withdrawls_punjab WHERE 1=1`
	var args []interface{}
	argCounter := 1
	if year != nil {
		query += ` AND "Year" = $1`
		args = append(args, *year)
		argCounter++
	}
	if season != nil {
		query += ` AND "Season" = $` + string(rune(argCounter+48))
		args = append(args, *season)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.CanalWithdrawlsPunjab
	for rows.Next() {
		var item model.CanalWithdrawlsPunjab
		err := rows.Scan(&item.Year, &item.SeasonID, &item.Season, &item.AllCanalsPunjab, &item.FiveLinkedCanals, &item.MrLinkInternal, &item.HaveliCanals, &item.PanjnadCanals, &item.CentralBariDoabCanals, &item.SutlejValleyCanals, &item.ThalCanals, &item.TaunsaCanals, &item.Crbc)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetChannelsLengthDivisionsPunjab is the resolver for the getChannelsLengthDivisionsPunjab field.
func (r *queryResolver) GetChannelsLengthDivisionsPunjab(ctx context.Context, division *string) ([]*model.ChannelsLengthDivisionsPunjab, error) {
	query := `SELECT "Division", "Main Canals or Branches", "Major Distributories", "Minor Distributories", "Supply Escape Channels", "Sub-Total", "Drains", "Grand Total" FROM channels_length_divisions_punjab_21`
	var args []interface{}
	if division != nil {
		query += ` WHERE "Division" = $1`
		args = append(args, *division)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.ChannelsLengthDivisionsPunjab
	for rows.Next() {
		var item model.ChannelsLengthDivisionsPunjab
		err := rows.Scan(&item.Division, &item.MainCanalsOrBranches, &item.MajorDistributories, &item.MinorDistributories, &item.SupplyEscapeChannels, &item.SubTotal, &item.Drains, &item.GrandTotal)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetConsumptionFertilizersNutrientsPak is the resolver for the getConsumptionFertilizersNutrientsPak field.
func (r *queryResolver) GetConsumptionFertilizersNutrientsPak(ctx context.Context, year *string) ([]*model.ConsumptionFertilizersNutrientsPak, error) {
	query := `SELECT "Year", "Kharif N", "Kharif P", "Kharif K", "Kharif All", "Rabi N", "Rabi P", "Rabi K", "Rabi All", "Total N", "Total P", "Total K", "Total All" FROM consumption_fertilizers_nutrients_pak_2008_18`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.ConsumptionFertilizersNutrientsPak
	for rows.Next() {
		var item model.ConsumptionFertilizersNutrientsPak
		err := rows.Scan(&item.Year, &item.KharifN, &item.KharifP, &item.KharifK, &item.KharifAll, &item.RabiN, &item.RabiP, &item.RabiK, &item.RabiAll, &item.TotalN, &item.TotalP, &item.TotalK, &item.TotalAll)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetConsumptionOfPesticides is the resolver for the getConsumptionOfPesticides field.
func (r *queryResolver) GetConsumptionOfPesticides(ctx context.Context, year *string) ([]*model.ConsumptionOfPesticides, error) {
	query := `SELECT "Year", "Quantity (M.T) Imports", "Quantity (M.T) Production", "Quantity (M.T) Total", "Value (Million Rs.)" FROM consumption_of_pesticides_2008_18`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.ConsumptionOfPesticides
	for rows.Next() {
		var item model.ConsumptionOfPesticides
		err := rows.Scan(&item.Year, &item.QuantityMTImports, &item.QuantityMTProduction, &item.QuantityMTTotal, &item.ValueMillionRs)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetCottonProductionPakistan is the resolver for the getCottonProductionPakistan field.
func (r *queryResolver) GetCottonProductionPakistan(ctx context.Context, year *string) ([]*model.CottonProductionPakistan, error) {
	query := `SELECT "Factor", "2016-17", "2017-18", "2018-19", "2019-20" FROM cotton_production_pakistan_2016_20`
	var args []interface{}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.CottonProductionPakistan
	for rows.Next() {
		var item model.CottonProductionPakistan
		err := rows.Scan(&item.Factor, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetCropAreaPunjab is the resolver for the getCropAreaPunjab field.
func (r *queryResolver) GetCropAreaPunjab(ctx context.Context, crop *string) ([]*model.CropAreaPunjab, error) {
	query := `SELECT "Crop", "Cropped Area", "%  of  Total" FROM crop_area_punjab_2020_21`
	var args []interface{}
	if crop != nil {
		query += ` WHERE "Crop" = $1`
		args = append(args, *crop)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.CropAreaPunjab
	for rows.Next() {
		var item model.CropAreaPunjab
		err := rows.Scan(&item.Crop, &item.CroppedArea, &item.PercentOfTotal)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetDistributionImprovedSeedsPunjab is the resolver for the getDistributionImprovedSeedsPunjab field.
func (r *queryResolver) GetDistributionImprovedSeedsPunjab(ctx context.Context, year *string) ([]*model.DistributionImprovedSeedsPunjab, error) {
	query := `SELECT "Year", "Wheat", "Paddy", "Cotton", "Maize", "Gram", "Potato", "Total (Met Ton)" FROM distribution_indeginous_improved_seeds_punjab`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.DistributionImprovedSeedsPunjab
	for rows.Next() {
		var item model.DistributionImprovedSeedsPunjab
		err := rows.Scan(&item.Year, &item.Wheat, &item.Paddy, &item.Cotton, &item.Maize, &item.Gram, &item.Potato, &item.TotalMetTon)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetFarmersTrainedCooperativeFarmingKpk is the resolver for the getFarmersTrainedCooperativeFarmingKpk field.
func (r *queryResolver) GetFarmersTrainedCooperativeFarmingKpk(ctx context.Context, month *string) ([]*model.FarmersTrainedCooperativeFarmingKpk, error) {
	query := `SELECT "Month", "Kohat", "D.I Khan", "Mansehra", "Hangu", "Mardan", "Tank", "Charsadda", "Swat", "Peshawar", "Shangla", "Haripur", "Bannu", "Chitral", "Nowshera", "Dir Upper", "Malakand", "Abbottabad", "Swabi", "Dir Lower", "Bunner", "Karak", "Lakki Marwat", "Battagram", "Torghar", "Kohistan" FROM farmers_trained_cooperative_farming_kpk`
	var args []interface{}
	if month != nil {
		query += ` WHERE "Month" = $1`
		args = append(args, *month)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.FarmersTrainedCooperativeFarmingKpk
	for rows.Next() {
		var item model.FarmersTrainedCooperativeFarmingKpk
		err := rows.Scan(&item.Month, &item.Kohat, &item.DiKhan, &item.Mansehra, &item.Hangu, &item.Mardan, &item.Tank, &item.Charsadda, &item.Swat, &item.Peshawar, &item.Shangla, &item.Haripur, &item.Bannu, &item.Chitral, &item.Nowshera, &item.DirUpper, &item.Malakand, &item.Abbottabad, &item.Swabi, &item.DirLower, &item.Bunner, &item.Karak, &item.LakkiMarwat, &item.Battagram, &item.Torghar, &item.Kohistan)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetFertilizerMachineryImpactKpk is the resolver for the getFertilizerMachineryImpactKpk field.
func (r *queryResolver) GetFertilizerMachineryImpactKpk(ctx context.Context, year *string, district *string, latitude *float64, longitude *float64) ([]*model.FertilizerMachineryImpactKpk, error) {
	query := `SELECT "Year", "Factors", "Sub-Factor", "Districts", "Amount" FROM fertilizer_machinery_impact_kpk_2016_17 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
		argCounter++
	} else if district != nil {
		query += ` AND "Districts" = $` + strconv.Itoa(argCounter)
		args = append(args, *district)
		argCounter++
	}

	if year != nil {
		query += ` AND "Year" = $` + strconv.Itoa(argCounter)
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.FertilizerMachineryImpactKpk
	for rows.Next() {
		var item model.FertilizerMachineryImpactKpk
		err := rows.Scan(&item.Year, &item.Factors, &item.SubFactor, &item.Districts, &item.Amount)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetFertilizerUsageProductionPunjab is the resolver for the getFertilizerUsageProductionPunjab field.
func (r *queryResolver) GetFertilizerUsageProductionPunjab(ctx context.Context, year *string, district *string, latitude *float64, longitude *float64) ([]*model.FertilizerUsageProductionPunjab, error) {
	query := `SELECT "Year", "Province", "Division", "District", "Usage (in 1000 nutirient tons)", "Area Sown Total (Wheat)", "Area Sown (Rice)", "Area Sown (Cotton)", "Area Sown (Sugarcane)", "Wheat Production ", "Rice Production ", "Cotton Production ", "Sugarcane Production", "Output/Acre (Wheat)", "Output/Acre (Rice)", "Output/Acre (Cotton)", "Output/Acre (Sugarcane)" FROM fertilizer_usage_production_punjab_2002_15 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
		argCounter++
	} else if district != nil {
		query += ` AND "District" = $` + strconv.Itoa(argCounter)
		args = append(args, *district)
		argCounter++
	}

	if year != nil {
		query += ` AND "Year" = $` + strconv.Itoa(argCounter)
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.FertilizerUsageProductionPunjab
	for rows.Next() {
		var item model.FertilizerUsageProductionPunjab
		err := rows.Scan(&item.Year, &item.Province, &item.Division, &item.District, &item.UsageIn1000NutrientTons, &item.AreaSownTotalWheat, &item.AreaSownRice, &item.AreaSownCotton, &item.AreaSownSugarcane, &item.WheatProduction, &item.RiceProduction, &item.CottonProduction, &item.SugarcaneProduction, &item.OutputAcreWheat, &item.OutputAcreRice, &item.OutputAcreCotton, &item.OutputAcreSugarcane)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetFertilizersSaleDistrictsPunjab is the resolver for the getFertilizersSaleDistrictsPunjab field.
func (r *queryResolver) GetFertilizersSaleDistrictsPunjab(ctx context.Context, district *string, latitude *float64, longitude *float64) ([]*model.FertilizersSaleDistrictsPunjab, error) {
	query := `SELECT "Division / District", "2015-16", "2016-17", "2017-18", "2018-19", "2019-20" FROM fertilizers_sale_districts_punjab_2015_20 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
		argCounter++
	} else if district != nil {
		query += ` AND "Division / District" ILIKE $` + strconv.Itoa(argCounter)
		args = append(args, "%"+*district+"%")
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.FertilizersSaleDistrictsPunjab
	for rows.Next() {
		var item model.FertilizersSaleDistrictsPunjab
		err := rows.Scan(&item.DivisionDistrict, &item.Year201516, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetFoodGrainsStorageCapacityPunjab is the resolver for the getFoodGrainsStorageCapacityPunjab field.
func (r *queryResolver) GetFoodGrainsStorageCapacityPunjab(ctx context.Context, district *string, latitude *float64, longitude *float64) ([]*model.FoodGrainsStorageCapacityPunjab, error) {
	query := `SELECT "Division / District", "House Type", "Silos/Bins/ Bini Shell", "Open Bulk Heads", "Total" FROM food_grains_storage_capacity_punjab WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
		argCounter++
	} else if district != nil {
		query += ` AND "Division / District" ILIKE $` + strconv.Itoa(argCounter)
		args = append(args, "%"+*district+"%")
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.FoodGrainsStorageCapacityPunjab
	for rows.Next() {
		var item model.FoodGrainsStorageCapacityPunjab
		err := rows.Scan(&item.DivisionDistrict, &item.HouseType, &item.SilosBinsBiniShell, &item.OpenBulkHeads, &item.Total)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetForestsProductsPakistan is the resolver for the getForestsProductsPakistan field.
func (r *queryResolver) GetForestsProductsPakistan(ctx context.Context, year *string) ([]*model.ForestsProductsPakistan, error) {
	query := `SELECT "Year", "Timber (Thousand cub. Meters)", "Firewood (Thousand cub. Meters)", "Total (Thousand cub. Meters)", "Timber  (Million Rupees)", "Firewood  (Million Rupees)", "Total  (Million Rupees)" FROM forests_products_pakistan_2008_18`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.ForestsProductsPakistan
	for rows.Next() {
		var item model.ForestsProductsPakistan
		err := rows.Scan(&item.Year, &item.TimberThousandCubMeters, &item.FirewoodThousandCubMeters, &item.TotalThousandCubMeters, &item.TimberMillionRupees, &item.FirewoodMillionRupees, &item.TotalMillionRupees)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetGeographyColumns is the resolver for the getGeographyColumns field.
func (r *queryResolver) GetGeographyColumns(ctx context.Context) ([]*model.GeographyColumns, error) {
	query := `SELECT f_table_catalog, f_table_schema, f_table_name, f_geography_column, coord_dimension, srid, type FROM geography_columns`

	rows, err := r.DB.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.GeographyColumns
	for rows.Next() {
		var item model.GeographyColumns
		err := rows.Scan(&item.FTableCatalog, &item.FTableSchema, &item.FTableName, &item.FGeographyColumn, &item.CoordDimension, &item.Srid, &item.Type)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetGeometryColumns is the resolver for the getGeometryColumns field.
func (r *queryResolver) GetGeometryColumns(ctx context.Context) ([]*model.GeometryColumns, error) {
	query := `SELECT f_table_catalog, f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, type FROM geometry_columns`

	rows, err := r.DB.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.GeometryColumns
	for rows.Next() {
		var item model.GeometryColumns
		err := rows.Scan(&item.FTableCatalog, &item.FTableSchema, &item.FTableName, &item.FGeometryColumn, &item.CoordDimension, &item.Srid, &item.Type)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetGroundTruthingSurveyAdb is the resolver for the getGroundTruthingSurveyADB field.
func (r *queryResolver) GetGroundTruthingSurveyAdb(ctx context.Context, province *string, district *string, season *string, latitude *float64, longitude *float64) ([]*model.GroundTruthingSurveyAdb, error) {
	query := `SELECT "ID", "Season", "Province", "District", "Date", "Latitude", "Longitude", "Code", "Land", "Description", "Stage" FROM "ground_truthing_survey_ADB" WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
		argCounter++
	} else {
		if province != nil {
			query += ` AND "Province" = $` + strconv.Itoa(argCounter)
			args = append(args, *province)
			argCounter++
		}
		if district != nil {
			query += ` AND "District" = $` + strconv.Itoa(argCounter)
			args = append(args, *district)
			argCounter++
		}
	}

	if season != nil {
		query += ` AND "Season" = $` + strconv.Itoa(argCounter)
		args = append(args, *season)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.GroundTruthingSurveyAdb
	for rows.Next() {
		var item model.GroundTruthingSurveyAdb
		err := rows.Scan(&item.ID, &item.Season, &item.Province, &item.District, &item.Date, &item.Latitude, &item.Longitude, &item.Code, &item.Land, &item.Description, &item.Stage)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetKharifRabiIrrigatedCrop is the resolver for the getKharifRabiIrrigatedCrop field.
func (r *queryResolver) GetKharifRabiIrrigatedCrop(ctx context.Context, crop *string) ([]*model.KharifRabiIrrigatedCrop, error) {
	query := `SELECT "Crop", "Total in 2018-19", "Irrigated in 2018-19", "Total in 2019-20", "Irrigated in 2019-20", "Total in 2020-21", "Irrigated 2020-21" FROM kharif_rabi_irrigated_crop_total_irrigated_area_2018_21`
	var args []interface{}
	if crop != nil {
		query += ` WHERE "Crop" = $1`
		args = append(args, *crop)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.KharifRabiIrrigatedCrop
	for rows.Next() {
		var item model.KharifRabiIrrigatedCrop
		err := rows.Scan(&item.Crop, &item.TotalIn201819, &item.IrrigatedIn201819, &item.TotalIn201920, &item.IrrigatedIn201920, &item.TotalIn202021, &item.Irrigated202021)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetLandUtilizationStatisticsPunjab is the resolver for the getLandUtilizationStatisticsPunjab field.
func (r *queryResolver) GetLandUtilizationStatisticsPunjab(ctx context.Context, year *string, district *string, latitude *float64, longitude *float64) ([]*model.LandUtilizationStatisticsPunjab, error) {
	query := `SELECT "Year", "Province/ Division/ District", "Geographical Area", "Reported Area", "Total Cultivated Area", "Current Fallows Cultivated Area", "Net Area Sown ", "Total Cropped Area", "Area Sown more than once", "Total Uncultivated Area", "Culturable waste Uncultivated Area", "Forest Uncultivated Area", "Not available for cultivation" FROM land_utilization_statistics_districts_punjab_2007_20 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
		argCounter++
	} else if district != nil {
		query += ` AND "Province/ Division/ District" ILIKE $` + strconv.Itoa(argCounter)
		args = append(args, "%"+*district+"%")
		argCounter++
	}

	if year != nil {
		query += ` AND "Year" = $` + strconv.Itoa(argCounter)
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.LandUtilizationStatisticsPunjab
	for rows.Next() {
		var item model.LandUtilizationStatisticsPunjab
		err := rows.Scan(&item.Year, &item.ProvinceDivisionDistrict, &item.GeographicalArea, &item.ReportedArea, &item.TotalCultivatedArea, &item.CurrentFallowsCultivatedArea, &item.NetAreaSown, &item.TotalCroppedArea, &item.AreaSownMoreThanOnce, &item.TotalUncultivatedArea, &item.CulturableWasteUncultivatedArea, &item.ForestUncultivatedArea, &item.NotAvailableForCultivation)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetLoansDisbursedZaraiTaraqiatBank is the resolver for the getLoansDisbursedZaraiTaraqiatBank field.
func (r *queryResolver) GetLoansDisbursedZaraiTaraqiatBank(ctx context.Context, purpose *string) ([]*model.LoansDisbursedZaraiTaraqiatBank, error) {
	query := `SELECT "Purpose", "2016-17", "2017-18", "2018-19", "2019-20", "2020-21" FROM loans_disbursed_zarai_taraqiat_bank_punjab`
	var args []interface{}
	if purpose != nil {
		query += ` WHERE "Purpose" = $1`
		args = append(args, *purpose)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.LoansDisbursedZaraiTaraqiatBank
	for rows.Next() {
		var item model.LoansDisbursedZaraiTaraqiatBank
		err := rows.Scan(&item.Purpose, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920, &item.Year202021)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetMauzzasCroppedAreaPunjab is the resolver for the getMauzzasCroppedAreaPunjab field.
func (r *queryResolver) GetMauzzasCroppedAreaPunjab(ctx context.Context, district *string, latitude *float64, longitude *float64) ([]*model.MauzzasCroppedAreaPunjab, error) {
	query := `SELECT "Division / District", "Number of Mauzas", "Cropped Area(1000 Hectares)" FROM mauzzas_cropped_area_punjab_2019_20 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
	} else if district != nil {
		query += ` AND "Division / District" ILIKE $` + strconv.Itoa(argCounter)
		args = append(args, "%"+*district+"%")
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.MauzzasCroppedAreaPunjab
	for rows.Next() {
		var item model.MauzzasCroppedAreaPunjab
		err := rows.Scan(&item.DivisionDistrict, &item.NumberOfMauzas, &item.CroppedArea1000Hectares)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetPercentageDistributionWheatPunjab is the resolver for the getPercentageDistributionWheatPunjab field.
func (r *queryResolver) GetPercentageDistributionWheatPunjab(ctx context.Context, district *string, latitude *float64, longitude *float64) ([]*model.PercentageDistributionWheatPunjab, error) {
	query := `SELECT "Province/ Division/ District", "2007-08", "2008-09", "2009-10", "2010-11", "2011-12", "2012-13", "2013-14", "2014-15", "2015-16", "2016-17", "2017-18", "2018-19", "2019-20" FROM percentage_distribution_wheat_districts_punjab_2009_20 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
	} else if district != nil {
		query += ` AND "Province/ Division/ District" ILIKE $` + strconv.Itoa(argCounter)
		args = append(args, "%"+*district+"%")
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.PercentageDistributionWheatPunjab
	for rows.Next() {
		var item model.PercentageDistributionWheatPunjab
		err := rows.Scan(&item.ProvinceDivisionDistrict, &item.Year200708, &item.Year200809, &item.Year200910, &item.Year201011, &item.Year201112, &item.Year201213, &item.Year201314, &item.Year201415, &item.Year201516, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetPredictionCropYieldRiskPunjab is the resolver for the getPredictionCropYieldRiskPunjab field.
func (r *queryResolver) GetPredictionCropYieldRiskPunjab(ctx context.Context, district *string, latitude *float64, longitude *float64) ([]*model.PredictionCropYieldRiskPunjab, error) {
	query := `SELECT "Division / District", "Wheat", "Gram", "Barley", "Potato", "Onion", "Canola", "Rapeseed and Mustard", "Masoor crop", "Mattar (Peas)", "Other Rabi Pulses", "Garlic", "Tabacco", "Linseed", "Corriander", "Mattar (green)", "Carrot", "Tomato", "Turnip", "Cauliflower", "Other Vegitables", "Guava", "Banana", "Grapefruit", "Kinnu", "Lemon", "Mandrine", "Orange", "Musumbi", "Sour Lime", "Sour Orange", "Sweet Lime", "Other Citrus", "Ber", "Loquat", "Mulbery", "Other Rabi fruits", "Barseem", "Lucern", "Others" FROM prediction_crop_yield_identify_risk_punjab WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and district_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
	} else if district != nil {
		query += ` AND "Division / District" ILIKE $` + strconv.Itoa(argCounter)
		args = append(args, "%"+*district+"%")
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.PredictionCropYieldRiskPunjab
	for rows.Next() {
		var item model.PredictionCropYieldRiskPunjab
		err := rows.Scan(&item.DivisionDistrict, &item.Wheat, &item.Gram, &item.Barley, &item.Potato, &item.Onion, &item.Canola, &item.RapeseedAndMustard, &item.MasoorCrop, &item.MattarPeas, &item.OtherRabiPulses, &item.Garlic, &item.Tabacco, &item.Linseed, &item.Corriander, &item.MattarGreen, &item.Carrot, &item.Tomato, &item.Turnip, &item.Cauliflower, &item.OtherVegetables, &item.Guava, &item.Banana, &item.Grapefruit, &item.Kinnu, &item.Lemon, &item.Mandrine, &item.Orange, &item.Musumbi, &item.SourLime, &item.SourOrange, &item.SweetLime, &item.OtherCitrus, &item.Ber, &item.Loquat, &item.Mulberry, &item.OtherRabiFruits, &item.Barseem, &item.Lucern, &item.Others)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetPriceWheatCities is the resolver for the getPriceWheatCities field.
func (r *queryResolver) GetPriceWheatCities(ctx context.Context, city *string, latitude *float64, longitude *float64) ([]*model.PriceWheatCities, error) {
	query := `SELECT "Commodity Item", "Unit (kg)", "City", "Dec 2020 Prices (Rs.)", "Sept 2021  Prices (Rs.)", "Dec 2021  Prices (Rs.)", "% Change in Dec 2021 Over Dec 2020", "% Change in Dec 2021 Over Sept 2021" FROM price_wheat_cities_2020_21 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32 // Add this to store grid_id

	// If coordinates provided, find grid cell and city_id
	if latitude != nil && longitude != nil {
		var cityID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&cityID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID // Store grid_id for later
		query += ` AND city_id = $` + strconv.Itoa(argCounter)
		args = append(args, cityID)
	} else if city != nil {
		query += ` AND "City" = $` + strconv.Itoa(argCounter)
		args = append(args, *city)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.PriceWheatCities
	for rows.Next() {
		var item model.PriceWheatCities
		err := rows.Scan(&item.CommodityItem, &item.UnitKg, &item.City, &item.Dec2020PricesRs, &item.Sept2021PricesRs, &item.Dec2021PricesRs, &item.PercentChangeInDec2021OverDec2020, &item.PercentChangeInDec2021OverSept2021)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID // Add grid_id to response
		results = append(results, &item)
	}
	return results, nil
}

// GetProcurementSupportPrices is the resolver for the getProcurementSupportPrices field.
func (r *queryResolver) GetProcurementSupportPrices(ctx context.Context, year *string) ([]*model.ProcurementSupportPrices, error) {
	query := `SELECT "Year", "Wheat", "Basmati 385", "Basmati Supper", "Irri-6", "Cotton", "Sugarcane" FROM procurement_support_prices_agri_commodities_40kg`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.ProcurementSupportPrices
	for rows.Next() {
		var item model.ProcurementSupportPrices
		err := rows.Scan(&item.Year, &item.Wheat, &item.Basmati385, &item.BasmatiSuper, &item.Irri6, &item.Cotton, &item.Sugarcane)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetProcurementWheatPunjabFoodDept is the resolver for the getProcurementWheatPunjabFoodDept field.
func (r *queryResolver) GetProcurementWheatPunjabFoodDept(ctx context.Context, district *string, latitude *float64, longitude *float64) ([]*model.ProcurementWheatPunjabFoodDept, error) {
	query := `SELECT "Division / District", "2016-17", "2017-18", "2018-19", "2019-20", "2020-21" FROM procurement_wheat_district_punjab_food_department WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32

	// If coordinates provided, find district_id and grid_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any grid cell")
		}

		gridID = &tempGridID
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
		argCounter++
	} else if district != nil {
		query += ` AND "Division / District" ILIKE $` + strconv.Itoa(argCounter)
		args = append(args, "%"+*district+"%")
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.ProcurementWheatPunjabFoodDept
	for rows.Next() {
		var item model.ProcurementWheatPunjabFoodDept
		err := rows.Scan(&item.DivisionDistrict, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920, &item.Year202021)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID
		results = append(results, &item)
	}
	return results, nil
}

// GetQuantumAcerageIndexImportantCrops is the resolver for the getQuantumAcerageIndexImportantCrops field.
func (r *queryResolver) GetQuantumAcerageIndexImportantCrops(ctx context.Context, crops *string, index *string) ([]*model.QuantumAcerageIndexImportantCrops, error) {
	query := `SELECT "Crops", "Index_ID", "Index", "2011-12", "2012-13", "2013-14", "2014-15", "2015-16", "2016-17", "2017-18", "2018-19", "2019-20", "2020-21" FROM quantum_acerage_index_importaant_crops_2011_21 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	if crops != nil {
		query += ` AND "Crops" = $1`
		args = append(args, *crops)
		argCounter++
	}
	if index != nil {
		query += ` AND "Index" = $2`
		args = append(args, *index)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.QuantumAcerageIndexImportantCrops
	for rows.Next() {
		var item model.QuantumAcerageIndexImportantCrops
		err := rows.Scan(&item.Crops, &item.IndexID, &item.Index, &item.Year201112, &item.Year201213, &item.Year201314, &item.Year201415, &item.Year201516, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920, &item.Year202021)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetRainfallPakistan is the resolver for the getRainfallPakistan field.
func (r *queryResolver) GetRainfallPakistan(ctx context.Context, year *int32, month *string) ([]*model.RainfallPakistan, error) {
	query := `SELECT " Year", "Month", "Rainfall (mm)" FROM rainfall_1901_2016_pakistan WHERE 1=1`
	var args []interface{}
	argCounter := 1
	if year != nil {
		query += ` AND " Year" = $1`
		args = append(args, *year)
		argCounter++
	}
	if month != nil {
		query += ` AND "Month" = $2`
		args = append(args, *month)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.RainfallPakistan
	for rows.Next() {
		var item model.RainfallPakistan
		err := rows.Scan(&item.Year, &item.Month, &item.RainfallMm)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetRainfallSelectedStationsPunjab is the resolver for the getRainfallSelectedStationsPunjab field.
func (r *queryResolver) GetRainfallSelectedStationsPunjab(ctx context.Context, year *int32, month *string) ([]*model.RainfallSelectedStationsPunjab, error) {
	query := `SELECT "Year", "Month", "Bahawalnagar", "Bahawalpur", "Jhelum", "Khanpur", "Lahore", "Multan", "Murree", "Rawalpindi / Islamabad", "Sargodha", "Sialkot" FROM rainfall_selected_stations_punjab_2010_21 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	if year != nil {
		query += ` AND "Year" = $1`
		args = append(args, *year)
		argCounter++
	}
	if month != nil {
		query += ` AND "Month" = $2`
		args = append(args, *month)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.RainfallSelectedStationsPunjab
	for rows.Next() {
		var item model.RainfallSelectedStationsPunjab
		err := rows.Scan(&item.Year, &item.Month, &item.Bahawalnagar, &item.Bahawalpur, &item.Jhelum, &item.Khanpur, &item.Lahore, &item.Multan, &item.Murree, &item.RawalpindiIslamabad, &item.Sargodha, &item.Sialkot)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetSmallDamsPunjab is the resolver for the getSmallDamsPunjab field.
func (r *queryResolver) GetSmallDamsPunjab(ctx context.Context, district *string, tehsil *string) ([]*model.SmallDamsPunjab, error) {
	query := `SELECT "Name of Small Dam", "District", "Tehsil", "Length of Canal (ft)", "Gross Storage Capacity (Aft)", "Actual Irrigation in  Acres" FROM small_dams_district_tehsil_punjab_2018_19 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	if district != nil {
		query += ` AND "District" = $1`
		args = append(args, *district)
		argCounter++
	}
	if tehsil != nil {
		query += ` AND "Tehsil" = $2`
		args = append(args, *tehsil)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.SmallDamsPunjab
	for rows.Next() {
		var item model.SmallDamsPunjab
		err := rows.Scan(&item.NameOfSmallDam, &item.District, &item.Tehsil, &item.LengthOfCanalFt, &item.GrossStorageCapacityAft, &item.ActualIrrigationInAcres)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetSpatialRefSys is the resolver for the getSpatialRefSys field.
func (r *queryResolver) GetSpatialRefSys(ctx context.Context, srid *int32) ([]*model.SpatialRefSys, error) {
	query := `SELECT srid, auth_name, auth_srid, srtext, proj4text FROM spatial_ref_sys`
	var args []interface{}
	if srid != nil {
		query += ` WHERE srid = $1`
		args = append(args, *srid)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.SpatialRefSys
	for rows.Next() {
		var item model.SpatialRefSys
		err := rows.Scan(&item.Srid, &item.AuthName, &item.AuthSrid, &item.Srtext, &item.Proj4text)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetStockWheatPunjabGovt is the resolver for the getStockWheatPunjabGovt field.
func (r *queryResolver) GetStockWheatPunjabGovt(ctx context.Context, month *string) ([]*model.StockWheatPunjabGovt, error) {
	query := `SELECT "Month", "2017-18", "2018-19", "2019-20", "2020-21", "2021-22" FROM stock_wheat_punjab_govt`
	var args []interface{}
	if month != nil {
		query += ` WHERE "Month" = $1`
		args = append(args, *month)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.StockWheatPunjabGovt
	for rows.Next() {
		var item model.StockWheatPunjabGovt
		err := rows.Scan(&item.Month, &item.Year201718, &item.Year201819, &item.Year201920, &item.Year202021, &item.Year202122)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetTemperatureRainTrends is the resolver for the getTemperatureRainTrends field.
func (r *queryResolver) GetTemperatureRainTrends(ctx context.Context, city *string, month *string, latitude *float64, longitude *float64) ([]*model.TemperatureRainTrends, error) {
	query := `SELECT "Month", "City_ID", "City", "Highest Recorded Temperature in Celsius ", "Highest Recorded Temperature date", "Lowest Recorded Temperature in Celsius mum Temperature in Celsi", "Lowest Recorded Temperature date", "Monthly Heaviest Rainfall in mm", "Heaviest Rainfall date" FROM temperature_rain_trends_major_cities WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32

	// If coordinates provided, find city_id and grid_id
	if latitude != nil && longitude != nil {
		var cityID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT city_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&cityID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any city")
		}

		gridID = &tempGridID
		query += ` AND city_id = $` + strconv.Itoa(argCounter)
		args = append(args, cityID)
		argCounter++
	} else if city != nil {
		query += ` AND "City" = $` + strconv.Itoa(argCounter)
		args = append(args, *city)
		argCounter++
	}

	if month != nil {
		query += ` AND "Month" = $` + strconv.Itoa(argCounter)
		args = append(args, *month)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.TemperatureRainTrends
	for rows.Next() {
		var item model.TemperatureRainTrends
		err := rows.Scan(&item.Month, &item.CityID, &item.City, &item.HighestRecordedTemperatureInCelsius, &item.HighestRecordedTemperatureDate, &item.LowestRecordedTemperatureInCelsius, &item.LowestRecordedTemperatureDate, &item.MonthlyHeaviestRainfallInMm, &item.HeaviestRainfallDate)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID
		results = append(results, &item)
	}
	return results, nil
}

// GetTractorsImportedPakistan is the resolver for the getTractorsImportedPakistan field.
func (r *queryResolver) GetTractorsImportedPakistan(ctx context.Context, year *string) ([]*model.TractorsImportedPakistan, error) {
	query := `SELECT "Year", "During the Year", "Cumulative Number" FROM tractors_imported_pakistan`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.TractorsImportedPakistan
	for rows.Next() {
		var item model.TractorsImportedPakistan
		err := rows.Scan(&item.Year, &item.DuringTheYear, &item.CumulativeNumber)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetUsageOfFertilizersCropsNutrients is the resolver for the getUsageOfFertilizersCropsNutrients field.
func (r *queryResolver) GetUsageOfFertilizersCropsNutrients(ctx context.Context, year *string) ([]*model.UsageOfFertilizersCropsNutrients, error) {
	query := `SELECT "Year", "Wheat", "Rice", "Maize", "Cotton", "Sugarcane", "Others", "Total" FROM usage_of_fertilizers_crops_nutrients`
	var args []interface{}
	if year != nil {
		query += ` WHERE "Year" = $1`
		args = append(args, *year)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.UsageOfFertilizersCropsNutrients
	for rows.Next() {
		var item model.UsageOfFertilizersCropsNutrients
		err := rows.Scan(&item.Year, &item.Wheat, &item.Rice, &item.Maize, &item.Cotton, &item.Sugarcane, &item.Others, &item.Total)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// 45. GetUserAccountData is the resolver for the getUserAccountData field.
func (r *queryResolver) GetUserAccountData(ctx context.Context, id *int32, username *string, email *string, role *string) ([]*model.UserAccountData, error) {
	query := `SELECT "ID", "Username", "Email", "Password", "Role", "Status", "Joined" FROM user_account_data WHERE 1=1`
	var args []interface{}
	argCounter := 1

	if id != nil {
		query += ` AND "ID" = $1`
		args = append(args, *id)
		argCounter++
	}
	if username != nil {
		query += ` AND "Username" = $` + string(rune(argCounter+48))
		args = append(args, *username)
		argCounter++
	}
	if email != nil {
		query += ` AND "Email" = $` + string(rune(argCounter+48))
		args = append(args, *email)
		argCounter++
	}
	if role != nil {
		query += ` AND "Role" = $` + string(rune(argCounter+48))
		args = append(args, *role)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.UserAccountData
	for rows.Next() {
		var item model.UserAccountData
		err := rows.Scan(&item.ID, &item.Username, &item.Email, &item.Password, &item.Role, &item.Status, &item.Joined)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetDashboard is the resolver for the getDashboard field.
func (r *queryResolver) GetDashboard(ctx context.Context, token string) (*model.DashboardData, error) {
	// Step 1: Validate token
	claims, err := validateJWT(token)
	if err != nil {
		return nil, err
	}
	role := claims.Role
	userID := claims.ID

	// Step 2: Return role-specific dashboard data
	var permissions []string
	var statistics string
	var pages []*model.DashboardPage

	switch role {

	case "admin":
		permissions = []string{
			"view_all_users", "add_user", "edit_user", "delete_user",
			"view_all_farms", "add_farm", "edit_farm", "delete_farm",
			"view_all_groups", "manage_groups", "view_all_projects", "manage_projects", "manage_roles", "view_system_logs"}

		// Fetch admin-specific statistics
		var totalUsers, totalFarms, totalGroups, totalProjects string
		r.DB.QueryRowContext(ctx, `SELECT COUNT(*) FROM user_account_data`).Scan(&totalUsers)
		r.DB.QueryRowContext(ctx, `SELECT COUNT(*) FROM farm_list`).Scan(&totalFarms)
		r.DB.QueryRowContext(ctx, `SELECT COUNT(*) FROM group_list`).Scan(&totalGroups)
		r.DB.QueryRowContext(ctx, `SELECT COUNT(*) FROM user_project`).Scan(&totalProjects)
		statistics = fmt.Sprintf("Total Users: %s, Total Farms: %s, Total Groups: %s, Total Projects: %s", totalUsers, totalFarms, totalGroups, totalProjects)

		pages = []*model.DashboardPage{
			{Name: "User Management", AccessibleTables: []string{"user_account_data"}},
			{Name: "Farm List", AccessibleTables: []string{"farm_list"}},
			{Name: "Group List", AccessibleTables: []string{"group_list"}},
			{Name: "Projects", AccessibleTables: []string{"user_project"}},
			{Name: "Map", AccessibleTables: []string{"farms", "field_boundaries"}},     // Will come from map API
			{Name: "Data Layers", AccessibleTables: []string{"farms", "user_project"}}, // Geo data,
			{Name: "System", AccessibleTables: []string{"user_account_data", "farm_list", "group_list"}},
		}

	case "farmer":
		permissions = []string{"view_own_farm", "edit_own_farm", "view_projects", "view_weather", "view_group_activities"}

		// Fetch farmer-specific statistics from database
		var farmCount, projectCount, groupCount string
		r.DB.QueryRowContext(ctx, `SELECT COUNT(*) FROM farm_list WHERE "User_ID" = $1`, userID).Scan(&farmCount)
		r.DB.QueryRowContext(ctx, `SELECT COUNT(*) FROM user_project WHERE "User_ID" = $1`, userID).Scan(&projectCount)
		r.DB.QueryRowContext(ctx, `SELECT COUNT(*) FROM group_list WHERE "User_ID" = $1`, userID).Scan(&groupCount)
		statistics = fmt.Sprintf("My Farms: %s, My Projects: %s, My Groups: %s", farmCount, projectCount, groupCount)
		pages = []*model.DashboardPage{
			{Name: "Map", AccessibleTables: []string{"farms", "field_boundaries", "weather_data"}}, // Will come from map API
			{Name: "Insights", AccessibleTables: []string{"yield_data", "soil_analysis", "crop_health"}},
			{Name: "Projects", AccessibleTables: []string{"user_project"}},
			{Name: "Chatbot", AccessibleTables: []string{"chat_history", "recommendations"}}, // After dev or API
			{Name: "Farmlist", AccessibleTables: []string{"farm_list"}},
			{Name: "Account", AccessibleTables: []string{"user_account_data"}},
			/*
				{Name: "Map", AccessibleTables: []string{"farms", "field_boundaries", "weather_stations"}}, // Data layers for map API
				{Name: "Projects", AccessibleTables: []string{"projects", "project_activities", "project_resources}},
				{Name: "Farmlist", AccessibleTables: []string{"farms", "crops", "livestock"}},
				{Name: "Chatbot", AccessibleTables: []string{"crop_database", "farm_records", "weather_data"}}, // Data sources for chatbot
				{Name: "Account", AccessibleTables: []string{"user_account_data", "profile_settings"}},
			*/
		}
	default:
		permissions = []string{}
		statistics = ""
		pages = []*model.DashboardPage{}
	}

	return &model.DashboardData{
		Role:        role,
		Statistics:  &statistics,
		Permissions: permissions,
		Pages:       pages,
	}, nil
}

// ValidateToken is the resolver for the validateToken field.
func (r *queryResolver) ValidateToken(ctx context.Context, token string) (*model.UserAccountData, error) {
	// Step 1: Decode and verify JWT
	claims, err := validateJWT(token)
	if err != nil {
		return nil, err
	}

	// Step 2: Query fresh user data from database
	var username, email, role, joined string
	var status bool

	err = r.DB.QueryRowContext(ctx,
		`SELECT "Username", "Email", "Role", "Status", "Joined" FROM user_account_data WHERE "ID" = $1`, claims.ID).
		Scan(&username, &email, &role, &status, &joined)
	if err != nil {
		return nil, err
	}

	// Step 3: Return user data
	user := &model.UserAccountData{
		ID:       claims.ID,
		Username: &username,
		Email:    &email,
		Password: nil, // Never return password
		Role:     &role,
		Status:   &status,
		Joined:   &joined,
	}
	return user, nil
}

// GetWaterDeliveryPakistan is the resolver for the getWaterDeliveryPakistan field.
func (r *queryResolver) GetWaterDeliveryPakistan(ctx context.Context, source *string) ([]*model.WaterDeliveryPakistan, error) {
	query := `SELECT "Source", "Urban", "Rural", "Total" FROM water_delivery_pakistan_2013_20`
	var args []interface{}
	if source != nil {
		query += ` WHERE "Source" = $1`
		args = append(args, *source)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.WaterDeliveryPakistan
	for rows.Next() {
		var item model.WaterDeliveryPakistan
		err := rows.Scan(&item.Source, &item.Urban, &item.Rural, &item.Total)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetWatercoursesImprovedDistrictTehsil is the resolver for the getWatercoursesImprovedDistrictTehsil field.
func (r *queryResolver) GetWatercoursesImprovedDistrictTehsil(ctx context.Context, district *string) ([]*model.WatercoursesImprovedDistrictTehsil, error) {
	query := `SELECT "District / Tehsil", "No of Improved Watercourses", "Command Area (Acres)" FROM watercourses_improved_district_tehsil_19_20`
	var args []interface{}
	if district != nil {
		query += ` WHERE "District / Tehsil" ILIKE $1`
		args = append(args, "%"+*district+"%")
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.WatercoursesImprovedDistrictTehsil
	for rows.Next() {
		var item model.WatercoursesImprovedDistrictTehsil
		err := rows.Scan(&item.DistrictTehsil, &item.NoOfImprovedWatercourses, &item.CommandAreaAcres)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// GetWheatProcurementPunjab is the resolver for the getWheatProcurementPunjab field.
func (r *queryResolver) GetWheatProcurementPunjab(ctx context.Context, district *string, latitude *float64, longitude *float64) ([]*model.WheatProcurementPunjab, error) {
	query := `SELECT "Division / District", "2016-17", "2017-18", "2018-19", "2019-20", "2020-21" FROM wheat_procurement_punjab_2012_21 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32

	// If coordinates provided, find district_id and grid_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any district")
		}

		gridID = &tempGridID
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
	} else if district != nil {
		query += ` AND "Division / District" ILIKE $` + strconv.Itoa(argCounter)
		args = append(args, "%"+*district+"%")
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.WheatProcurementPunjab
	for rows.Next() {
		var item model.WheatProcurementPunjab
		err := rows.Scan(&item.DivisionDistrict, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920, &item.Year202021)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID
		results = append(results, &item)
	}
	return results, nil
}

// GetWheatReleaseDistrictPunjab is the resolver for the getWheatReleaseDistrictPunjab field.
func (r *queryResolver) GetWheatReleaseDistrictPunjab(ctx context.Context, district *string, latitude *float64, longitude *float64) ([]*model.WheatReleaseDistrictPunjab, error) {
	query := `SELECT "Division / District", "2016-17", "2017-18", "2018-19", "2019-20", "2020-21" FROM wheat_release_district_punjab_2016_21 WHERE 1=1`
	var args []interface{}
	argCounter := 1
	var gridID *int32

	// If coordinates provided, find district_id and grid_id
	if latitude != nil && longitude != nil {
		var districtID int
		var tempGridID int32
		err := r.DB.QueryRowContext(ctx,
			`SELECT district_id, grid_id FROM grid_1km 
			 WHERE ST_Contains(cell_geom, ST_SetSRID(ST_MakePoint($1, $2), 4326))`,
			*longitude, *latitude).Scan(&districtID, &tempGridID)

		if err != nil {
			return nil, fmt.Errorf("coordinates not found in any district")
		}

		gridID = &tempGridID
		query += ` AND district_id = $` + strconv.Itoa(argCounter)
		args = append(args, districtID)
	} else if district != nil {
		query += ` AND "Division / District" ILIKE $` + strconv.Itoa(argCounter)
		args = append(args, "%"+*district+"%")
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.WheatReleaseDistrictPunjab
	for rows.Next() {
		var item model.WheatReleaseDistrictPunjab
		err := rows.Scan(&item.DivisionDistrict, &item.Year201617, &item.Year201718, &item.Year201819, &item.Year201920, &item.Year202021)
		if err != nil {
			return nil, err
		}
		item.GridID = gridID
		results = append(results, &item)
	}
	return results, nil
}

// GetYearlyCropDataPakistan is the resolver for the getYearlyCropDataPakistan field.
func (r *queryResolver) GetYearlyCropDataPakistan(ctx context.Context, fiscalYear *string) ([]*model.YearlyCropDataPakistan, error) {
	query := `SELECT "Fiscal Year", "Area (Wheat)", "Production (Wheat)", "Yield (Wheat)", "Area (Cotton)", "Production (Cotton)", "Yield (Cotton)", "Area (Suagarcane)", "Production (Suagarcane)", "Yield (Suagarcane)", "Area (Rice)", "Production (Rice)", "Yield (Rice)", "Area (Maize)", "Production (Maize)", "Yield (Maize)" FROM yearly_crop_data_pakistan`
	var args []interface{}
	if fiscalYear != nil {
		query += ` WHERE "Fiscal Year" = $1`
		args = append(args, *fiscalYear)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.YearlyCropDataPakistan
	for rows.Next() {
		var item model.YearlyCropDataPakistan
		err := rows.Scan(&item.FiscalYear, &item.AreaWheat, &item.ProductionWheat, &item.YieldWheat, &item.AreaCotton, &item.ProductionCotton, &item.YieldCotton, &item.AreaSugarcane, &item.ProductionSugarcane, &item.YieldSugarcane, &item.AreaRice, &item.ProductionRice, &item.YieldRice, &item.AreaMaize, &item.ProductionMaize, &item.YieldMaize)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// 51. GetFarmListData is the resolver for the getFarmListData field.
func (r *queryResolver) GetFarmListData(ctx context.Context, groupName *string) ([]*model.FarmListData, error) {
	query := `SELECT "Group Name", "Address", "Number of Farms", "Number of Workers", "Actions" FROM public.farm_list WHERE 1=1`
	args := []interface{}{}

	if groupName != nil {
		query += ` AND "Group Name" = $1`
		args = append(args, *groupName)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.FarmListData
	for rows.Next() {
		var item model.FarmListData
		err := rows.Scan(&item.GroupName, &item.Address, &item.NumberOfFarms, &item.NumberOfWorkers, &item.Actions)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}

	if err = rows.Err(); err != nil {
		return nil, err
	}

	return results, nil
}

// 52. GetUserProjectData is the resolver for the getUserProjectData field.
func (r *queryResolver) GetUserProjectData(ctx context.Context, latitude *float64, longitude *float64) ([]*model.UserProjectData, error) {
	query := `SELECT "Latitude", "Longitude", "Region", "City", "District", "Address", "Size (sqm)" FROM public.user_project WHERE 1=1`
	args := []interface{}{}
	argCount := 1

	if latitude != nil {
		query += ` AND "Latitude" = $` + string(rune(argCount+'0'))
		args = append(args, *latitude)
		argCount++
	}
	if longitude != nil {
		query += ` AND "Longitude" = $` + string(rune(argCount+'0'))
		args = append(args, *longitude)
		argCount++
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.UserProjectData
	for rows.Next() {
		var item model.UserProjectData
		err := rows.Scan(&item.Latitude, &item.Longitude, &item.Region, &item.City, &item.District, &item.Address, &item.SizeSqm)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}

	if err = rows.Err(); err != nil {
		return nil, err
	}

	return results, nil
}

// 53. GetGroupListData is the resolver for the getGroupListData field.
func (r *queryResolver) GetGroupListData(ctx context.Context, username *string, email *string, status *bool) ([]*model.GroupListData, error) {
	query := `SELECT "Username", "Email", "Phone", "Role", "Status", "Joined" FROM public.group_list WHERE 1=1`
	args := []interface{}{}
	argCount := 1

	if username != nil {
		query += ` AND "Username" = $` + string(rune(argCount+'0'))
		args = append(args, *username)
		argCount++
	}
	if email != nil {
		query += ` AND "Email" = $` + string(rune(argCount+'0'))
		args = append(args, *email)
		argCount++
	}
	if status != nil {
		query += ` AND "Status" = $` + string(rune(argCount+'0'))
		args = append(args, *status)
		argCount++
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.GroupListData
	for rows.Next() {
		var item model.GroupListData
		err := rows.Scan(&item.Username, &item.Email, &item.Phone, &item.Role, &item.Status, &item.Joined)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}

	if err = rows.Err(); err != nil {
		return nil, err
	}

	return results, nil
}

// 54. GetForgetPassword is the resolver for the getForgetPassword field.
func (r *queryResolver) GetForgetPassword(ctx context.Context, userID *int32, token *string) ([]*model.ForgetPassword, error) {
	query := `SELECT "ID", "User_ID", "Email", "Token", "Expire_at", "Used", "Created" FROM forgot_password_functionality WHERE 1=1`
	var args []interface{}
	argCounter := 1

	if userID != nil {
		query += ` AND "User_ID" = $1`
		args = append(args, *userID)
		argCounter++
	}
	if token != nil {
		query += ` AND "Token" = $` + string(rune(argCounter+48))
		args = append(args, *token)
	}

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []*model.ForgetPassword
	for rows.Next() {
		var item model.ForgetPassword
		err := rows.Scan(&item.ID, &item.UserID, &item.Email, &item.Token, &item.ExpireAt, &item.Used, &item.Created)
		if err != nil {
			return nil, err
		}
		results = append(results, &item)
	}
	return results, nil
}

// ValidatePasswordResetToken is the resolver for the validatePasswordResetToken field.
func (r *queryResolver) ValidatePasswordResetToken(ctx context.Context, token string) (*model.PasswordResetValidation, error) {
	var userID int32
	var expireAt string
	var used bool

	err := r.DB.QueryRowContext(ctx,
		`SELECT "User_ID", "Expire_at", "Used" FROM forgot_password_functionality WHERE "Token" = $1`, token).Scan(&userID, &expireAt, &used)
	if err != nil {
		return &model.PasswordResetValidation{
			Valid:   false,
			Message: "Invalid token",
			UserID:  nil,
		}, nil
	}

	if used {
		return &model.PasswordResetValidation{
			Valid:   false,
			Message: "Token has already been used",
			UserID:  nil,
		}, nil
	}

	expireTime, _ := time.Parse("2006-01-02T15:04:05Z07:00", expireAt)
	if time.Now().After(expireTime) {
		return &model.PasswordResetValidation{
			Valid:   false,
			Message: "Token has expired",
			UserID:  nil,
		}, nil
	}

	return &model.PasswordResetValidation{
		Valid:   true,
		Message: "Token is valid",
		UserID:  &userID,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
